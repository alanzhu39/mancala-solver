Mancala Solver
- solver for Mancala (based on GamePigeon version rules)
- can select different modes (capture/avalanche, normal/random initialization)

TODO:
- avalanche mode (currently only implmementing capture mode)

3/19/23:
In progress:
- transposition table
  - we can make this only dependent on active counters, and check parity so it is turn agnostic. surely this will pop
- futility pruning (one side has a big enough lead that can't win even if the rest of the stones are captured)
- move ordering
  - adding move ordering, where starting move to be considered is transposition entry move
    - this gives significant speedup!
- how deep can we go with the optimizations?
  - current max depth of around 15-20
    - search depth 19, (6, 1): .872 s
    - search depth 19, (6, 2): 14.27 s
- performance on random starting mode?

Transposition table notes:
- tested flipped position checking and ignoring stores, both seem to have minimal benefit
  - negligible improvement over simply hashing the full state
- adding node depth and node type to transposition entries
  - node type necessary for accurate results (we reassign alpha/beta based on type, still have to find a way to get exact nodes)
  - depth-preferred replacement seems to work better based on early testing (vs replace on any collision)
    - especially as max search depth increases
    - for some reason, much faster on (6, 5) as opposed to (6, 3)?
- using 64-bit hash to make more resistant to collisions
  - add full collision resistance in the future



3/18/23:

In progress:
- agent integration testing
  - benchmarking (states explorable, max search depth computable, does transposition table work, etc.)
- central solver algorithm
  - alpha beta w memory
  - transposition table

Finished:
- testing agent + game
  - cli display working fine
- central solver algorithm
  - mdtf
  - alpha beta
  - iterative deepening
- agent on small game:
  - 2 stones per pit starting?
  - agent verified for (6, 1), (6, 2) on irving rules
  - I didn't read the paper closely enough, turns out that they perform the capture even if the opposing pit is not empty which was giving me different results
  - Once fixed, was able to repeat the game values and perfect games for 1 and 2 starting stones
  - Still had to fix some of the algorithm logic:
    - using pairs to pass move_vals since the bit shifting was wrong because there could be negative values
    - tested soft-fail alpha beta, does not perform correctly with mtdf
- game logic (making moves) generally good, not really checking for input validity right now though
  - fixed score logic (should not have sign dependence on turn)
  - added capture logic (we are following GamePigeon rules for this, so no capture on empty opposite pit)
- printing board works fine (CLI version playable)



3/17/23:
On LLM tools: these tools seem very strong.
- GitHub Copilot is suggesting really useful stuff and can provide very pertinent comments and code understanding as well.
  - eg. writing docstring for GameState struct
- ChatGPT is great for providing skeletons of what I want to implement and a good general structure of the codebase I want.
  - eg. today with the transposition table skeleton (great understanding of zobrist hash, and transposition table entries)
  - even its game state struct matched pretty well with my state struct

Components:
- game rules
- solver
  - endgame table
  - transposition table (search tree cache)
  - futility pruning
- CLI
